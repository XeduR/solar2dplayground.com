[
    {
        "title": "Empty",
        "code": "-- Here's an empty project for you to work with.\n\n"
    },
    
    {
        "title": "Crate",
        "code": "-- Sample code by Eetu Rantanen\n\n-- Change the background to blue.\ndisplay.setDefault( \"background\", 0, 0.3, 0.8 )\n\n-- Require and start the physics engine.\nlocal physics = require(\"physics\")\nphysics.start()\nphysics.setGravity( 0, 98.1 ) -- Setting a very high gravity.\n\n-- Create a sword altar, the ground and a crate, and give them all physics bodies.\nlocal swordShape = { -2, -62, 9, -62, 49, 10, 49, 95, -40, 95, -40, 10 }\nlocal sword = display.newImage( \"img/alter.png\", 510, 490 )\nphysics.addBody( sword, \"dynamic\", { density=1, friction=0.9, bounce=0, shape=swordShape } )\n\nlocal block = display.newImage( \"img/pushBlock3.png\", 480, 100 )\nphysics.addBody( block, \"dynamic\", { density=1, friction=2, bounce=0 } )\nblock.angularDamping = 3\n-- block:setFillColor( 1, 0, 0 ) -- Uncomment this line to apply red tint to the block.\n\nfor i = 1, 4 do\n\tlocal ground = display.newImage( \"img/platformBase2.png\", i*250-160, 630 )\n\tphysics.addBody( ground, \"static\", { density=1, friction=0.9, bounce=0 } )\nend\n\nlocal text = display.newText( \"Drag the block with your mouse\", 640, 40, native.systemFontBold, 40 )\n\nlocal function dragObject( event, params )\n\tlocal body = event.target\n\tlocal phase = event.phase\n\tlocal stage = display.getCurrentStage()\n\n\tif \"began\" == phase then\n\t\tstage:setFocus( body )\n\t\tbody.isFocus = true\n\t\tbody.tempJoint = physics.newJoint( \"touch\", body, event.x, event.y )\n\n\telseif body.isFocus then\n\t\tif \"moved\" == phase then\n\t\t\tbody.tempJoint:setTarget( event.x, event.y )\n\n\t\telseif \"ended\" == phase or \"cancelled\" == phase then\n\t\t\tstage:setFocus( nil )\n\t\t\tbody.isFocus = false\t\n\t\t\tbody.tempJoint:removeSelf()\n\n\t\tend\n\tend\n\n\treturn true\nend\nblock:addEventListener( \"touch\", dragObject )\n-- sword:addEventListener( \"touch\", dragObject ) -- Uncomment to make the sword draggable too."
    },
    
    {
        "title": "Memory",
        "code": "-- Sample code by Eetu Rantanen\n\n-- Change the background to burgundy.\ndisplay.setDefault( \"background\", 0.55, 0, 0.2 )\nlocal images = { \"img/spaceWrench.png\", \"img/spaceGun.png\", \"img/spaceGrenade.png\", \"img/spaceKey.png\", \"img/spaceExtinguisher.png\", \"img/spaceCup.png\" }\n\n-- Save time by creating one function to handle flipping all tokens.\nlocal function flip( target, time, listener )\n\tlocal offset = 64\n\tif target.path.x1 == 64 then offset = 0 end\n\ttransition.to( target.path, { time=time, x1=offset, x2=offset, x3=-offset, x4=-offset, onComplete=listener } )\nend\n\nlocal canTouch, previous = true\nlocal function checkResult( target )\n\tif not previous then\n\t\tprevious = target\n\t\tcanTouch = true\n\telse\n\t\tif target.id == previous.id then\n\t\t\t-- In this sample code, nothing actually gets removed, they are just hidden.\n\t\t\ttransition.to( target.front, { time=300, alpha=0 } )\n\t\t\ttransition.to( previous.front, { time=300, alpha=0, onComplete=function()\n\t\t\t\tprevious = nil\n\t\t\t\tcanTouch = true\n\t\t\tend } )\n\t\telse\n\t\t\ttimer.performWithDelay( 300, function() -- Wait before flipping the tokens.\n\t\t\t\t -- First hide the front, then reveal the back.\n\t\t\t\tflip( target.front, 100, function() flip( target, 100 ) end )\n\t\t\t\tflip( previous.front, 100, function() flip( previous, 100, function()\n\t\t\t\t\t\tprevious = nil\n\t\t\t\t\t\tcanTouch = true\n\t\t\t\t\tend )\n\t\t\t\tend )\n\t\t\tend )\n\t\tend\n\tend\nend\n\nlocal function touchListener( event )\n\tif canTouch and event.phase == \"began\" then\n\t\tcanTouch = false -- Prevent further touches until the transitions have finished.\n\t\tflip( event.target, 100, function() -- First hide the back, then reveal the front.\n\t\t\tflip( event.target.front, 100, function() checkResult( event.target ) end )\n\t\tend )\n\tend\nend\n\nlocal token, n = {}, 1\nfor i = 1, 12 do\n\ttoken[i] = display.newImage( images[n], 270+math.floor((i-1)/3)*140, 180+math.fmod((i-1),3)*140 )\n\tflip( token[#token], 0 )\n\ttoken[i].back = display.newImage( \"img/spaceMonster.png\", token[i].x, token[i].y )\n\ttoken[i].back.front = token[i] -- Add a refence to the front side of the token.\n\ttoken[i].back.id = n -- This id will be used to identify correct pairs.\n\ttoken[i].back:addEventListener( \"touch\", touchListener )\n\tn = n+1\n\tif n > 6 then -- We've got six images, so create another pair of them.\n\t\tn = 1\n\tend\nend\n\nfor i = 1, 12 do -- Shuffle the tokens around.\n\tlocal target = math.random(12)\n\tlocal xNew, yNew = token[target].x, token[target].y\n\ttoken[target].x, token[target].y, token[target].back.x, token[target].back.y = token[i].x, token[i].y, token[i].x, token[i].y\n\ttoken[i].x, token[i].y, token[i].back.x, token[i].back.y = xNew, yNew, xNew, yNew\nend"
    },
    
    {
        "title": "Knight",
        "code": "-- Sample code by Eetu Rantanen\n\n-- Change the background to grey.\ndisplay.setDefault( \"background\", 0.2 )\nlocal instructions = display.newText( \"Use wasd or arrows to move. Press space to jump\", 480, 120, \"fonts/OpenSansRegular.ttf\", 32 )\n\n-- Image fills that will be used for enterFrame animations for the knight.\nlocal frameMove1 = { type = \"image\", filename = \"img/walk1.png\" }\nlocal frameMove2 = { type = \"image\", filename = \"img/walk2.png\" }\nlocal frameIdle = { type = \"image\", filename = \"img/stand.png\" }\nlocal frameJump = { type = \"image\", filename = \"img/jump.png\" }\n\n-- Declaring multiple similar variables on the same line to reduce repetition.\nlocal movementDirection, state1, inAir = \"right\", true, false\n-- The knight's start/previous x location, as well as movement speed, jump height and jump duration.\nlocal prevX, moveSpeed, jumpHeight, jumpDuration = 480, 8, 80, 200\nlocal knightGroup = display.newGroup() -- By adding the knight and his shadow to a group, we can handle both at the same time.\n\nlocal shadow = display.newCircle( knightGroup, prevX, 396, 46 )\nshadow:setFillColor(0,0.5) -- Give the shadow a 50% transparent black fill colour.\nshadow.yScale = 0.5 -- Adjust the yScale to give the shadow the proper perspective.\n\nlocal knight = display.newRect( knightGroup, prevX, 320, 156, 156 )\nknight.fill = frameIdle\n\nlocal action = {}\nlocal framesBetweenChange, currentFrame = 4, 1\nlocal function moveCharacter()\n\tlocal keyDown = false\n\t-- See if one of the selected action buttons is down and move the knight.\n\tif action[\"a\"] or action[\"left\"] then\n\t\tknightGroup:translate( -moveSpeed, 0 )\n\t\tkeyDown = true\n\tend\n\tif action[\"d\"] or action[\"right\"] then\n\t\tknightGroup:translate( moveSpeed, 0 )\n\t\tkeyDown = true\n\tend\n\tif action[\"w\"] or action[\"up\"] then\n\t\tknightGroup:translate( 0, -moveSpeed )\n\t\tkeyDown = true\n\tend\n\tif action[\"s\"] or action[\"down\"] then\n\t\tknightGroup:translate( 0, moveSpeed )\n\t\tkeyDown = true\n\tend\n\tif keyDown then -- Only animate if one of the keys is pressed.\n\t\tif movementDirection == \"right\" and knightGroup.x < prevX then\n\t\t\tmovementDirection = \"left\"\n\t\t\tknight.xScale = -1\n\t\telseif movementDirection == \"left\" and knightGroup.x > prevX then\n\t\t\tmovementDirection = \"right\"\n\t\t\tknight.xScale = 1\n\t\tend\n\t\tcurrentFrame = currentFrame+1\n\t\tif currentFrame > framesBetweenChange then\n\t\t\tstate1 = not state1 -- Changes true to false and vice versa.\n\t\t\tcurrentFrame = 1\n\t\tend\n\t\tif not inAir then\n\t\t\tif state1 then -- Change the shadow scale and knight.y to make the knight \"wobble\".\n\t\t\t\tknight.fill = frameMove2\n\t\t\t\tknight.y = shadow.y-76\n\t\t\t\tshadow.xScale, shadow.yScale = 1, 0.5\n\t\t\telse\n\t\t\t\tknight.fill = frameMove1\n\t\t\t\tknight.y = shadow.y-78\n\t\t\t\tshadow.xScale, shadow.yScale = 1.05, 0.45\n\t\t\tend\n\t\tend\n\t\tprevX = knightGroup.x\n\telseif not inAir then -- If the knight isn't moving or in the air, then toggle idle frame.\n\t\tknight.fill = frameIdle\n\tend\nend\n\nlocal function onKeyEvent( event )\n\tif event.phase == \"down\" then\n\t\taction[event.keyName] = true\n\t\tif event.keyName == \"space\" and not inAir then\n\t\t\tinAir = true\n\t\t\tknight.fill = frameJump\n\t\t\t-- Use transitions to jump the knight up and down, as well as animate the shadow.\n\t\t\ttransition.to( knight, { time=jumpDuration*0.5, y=knight.y-jumpHeight, onComplete=function()\n\t\t\t\ttransition.to( knight, { time=jumpDuration*0.5, y=knight.y+jumpHeight, onComplete=function()\n\t\t\t\t\tinAir = false\n\t\t\t\t\tknight.fill = frameIdle\n\t\t\t\tend })\n\t\t\tend })\n\t\t\ttransition.to( shadow, { time=jumpDuration*0.5, alpha=0.3, xScale=0.8, yScale=0.3, onComplete=function()\n\t\t\t\ttransition.to( shadow, { time=jumpDuration*0.5, alpha=0.5, xScale=1, yScale=0.5 })\n\t\t\tend })\n\t\tend\n\telse\n\t\taction[event.keyName] = false\n\tend\nend\n\nRuntime:addEventListener( \"enterFrame\", moveCharacter )\nRuntime:addEventListener( \"key\", onKeyEvent )"
    },
    
    {
        "title": "Bomb Tap",
        "code": "-- Sample code by Eetu Rantanen\n\ndisplay.setDefault( \"background\", 0.3 ) -- Change the background to grey.\nlocal physics = require(\"physics\")\nphysics.start()\nphysics.setGravity( 0, 50 )\nphysics.pause() -- Physics are paused until the game starts.\nlocal shiftTimer, started\n\nlocal platformTop = display.newImage( \"img/platformBase3.png\", display.contentCenterX, display.contentCenterY - 150 )\nphysics.addBody( platformTop, \"static\" )\nplatformTop.xScale, platformTop.yScale = -1, -1 -- Flip the top platform over its x and y-axes.\n\nlocal platformBottom = display.newImage( \"img/platformBase3.png\", display.contentCenterX, display.contentCenterY + 150 )\nphysics.addBody( platformBottom, \"static\" )\n\nlocal bomb = display.newImage( \"img/bombStroked.png\", display.contentCenterX, display.contentCenterY )\nphysics.addBody( bomb, { shape={ -20,-10, 28,-10, 28,40, -20,40 } } )\nbomb.isFixedRotation = true -- Prevent the bomb from spinning around its axis.\n\nlocal instructions = display.newText( \"Tap to Jump. Don't let the bomb get hit!\", display.contentCenterX, 40, \"fonts/OpenSansRegular.ttf\", 28 )\ninstructions:setFillColor( 1 )\n\nlocal function shift() -- Shift the platforms up or down at random.\n\tlocal yTo = math.random( -150, 150 )\n\ttransition.to( platformTop, { time=1000, y=display.contentCenterY-150+yTo } )\n\ttransition.to( platformBottom, { time=1000, y=display.contentCenterY+150+yTo } )\nend\n\nlocal function jump( event )\n\tif event.phase == \"began\" then\n\t\tif not started then -- Starts the game if it hasn't started yet.\n\t\t\tstarted = true\n\t\t\tphysics.start()\n\t\t\tshiftTimer = timer.performWithDelay( 750, shift, 0 )\n\t  \t\tdisplay.setDefault( \"background\", 0.3 ) -- Restore the background colour.\n\t\tend\n\t\tbomb:setLinearVelocity( 0, 0 ) -- Reset the bomb's current linear velocity.\n\t\tbomb:applyLinearImpulse( 0, -0.3 ) -- And give it an upwards impulse.\n\tend\nend\n\nlocal function collision( event ) -- If a collision begins, it means the game is over.\n\tif event.phase == \"began\" then\n\t\tdisplay.setDefault( \"background\", 0.6, 0, 0 ) -- Make the background red to emphasise gameover.\n\t\ttimer.cancel( shiftTimer )\n\t\ttransition.cancel()\n\t\tphysics.pause()\n\t\ttimer.performWithDelay( 100, function()\n\t\t\tplatformTop.y, platformBottom.y, bomb.y = display.contentCenterY-150, display.contentCenterY+150, display.contentCenterY\n\t\t\tstarted = false\n\t\tend )\n\tend\nend\n\nRuntime:addEventListener( \"touch\", jump )\nRuntime:addEventListener( \"collision\", collision )"
    },
    
    {
        "title": "Physics Typer",
        "code": "-- Sample code by Michael Wilson.\n\n-- Change the background to grey.\ndisplay.setDefault( \"background\", 0.1 )\n\nlocal x, y = display.contentCenterX, display.contentCenterY -- source of the letters\nlocal rnd = math.random\n\n-- Help text.\ndisplay.newText( {text = \"Start typing...\", x = x, y = y/4, fontSize = 32 } )\n\n-- Require and start the physics engine.\nlocal physics = require(\"physics\")\nphysics.start()\nphysics.setGravity( 0, 64 ) -- Set gravity.\n\nlocal ground = display.newRect(x,display.contentHeight, display.contentWidth * 2, 16)\nground.alpha = 0.25\nphysics.addBody(ground, \"static\")\n\n-- Text options.\nlocal options = { x = x, y = y, fontSize = 128, font = native.systemFontBold }\n\n-- Called when a key event has been received.\nlocal function key( event )\n\tif event.phase == \"up\" then\n\t\t-- Create the key you pressed.\n\t\toptions.text = event.keyName:len() == 1 and event.keyName or \"?\" -- One letter keys only.\n\t\tlocal letter = display.newText( options )\n\t\t-- Render the text to a display object.\n\t\tlocal object = display.capture(letter)\n\t\t-- Add a premade shader.\n\t\tobject.fill.effect = \"filter.colorChannelOffset\"\n\t\tobject.fill.effect.xTexels = 4\n\t\tobject.fill.effect.yTexels = 4\n\t\tobject:translate(x,y) -- Move from 0,0.\n\t\t-- Remove the letter.\n\t\tdisplay.remove(letter)\n\t\t-- Let's give it a quick physics body.\n\t\tphysics.addBody(object, { radius = 32, bounce = 0.5, friction = 0 } )\n\t\tobject.linearDamping = 1\n\t\tobject.angularDamping= 1\n\t\t-- Give it a push.\n\t\tobject:applyLinearImpulse(rnd()-rnd(),-rnd()-rnd(),rnd(),rnd())\n\t\tobject.angularVelocity = object.angularVelocity * 0.025 -- cap spin speed\n\tend\nend\n\n-- Add the key listener.\nRuntime:addEventListener( \"key\", key )"
    },
    
    {
        "title": "Flame",
        "code": "-- Sample code by Michael Wilson\n\n-- Change the background to grey.\ndisplay.setDefault( \"background\", 0.1 )\n\nlocal x, y = display.contentCenterX, display.contentCenterY -- Source of flame.\nlocal rnd = math.random\n\n-- Run every frame.\nlocal function enterFrame()\n\tlocal flame = display.newCircle(x,y, math.random(32,64))\n\tflame:setFillColor(rnd() + 0.5, rnd() + 0.2, 0)\n\tflame.blendMode = \"add\"\n\tflame.alpha = 0.5\n\n\t-- Kill the particle when done.\n\tlocal function die()\n\t\tdisplay.remove(flame)\n\tend\n\n\t-- Start a transition.\n\ttransition.to(flame, {\n\t\tdelta = true, -- Move from current location.\n\t\ttime = 1000, -- In 1.0 seconds.\n\t\tx = rnd(-16,16), -- Wiggle.\n\t\ty = rnd(-384, -256), -- Go up.\n\t\txScale = -0.9, -- Shrink.\n\t\tyScale = -0.9,\n\t\tonComplete = die, -- And die.\n\t})\nend\n\n-- Called when a mouse event has been received.\nlocal function mouse( event )\n\tx, y = event.x or x, event.y or y -- Take a new x,y or keep the old x,y.\nend\n\n-- Add the mouse and enterFrame events.\nRuntime:addEventListener( \"mouse\", mouse )\nRuntime:addEventListener( \"enterFrame\", enterFrame )"
    }
]